# 		    GNU GENERAL PUBLIC LICENSE
# 		       Version 2, June 1991
# 
#  Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#  Everyone is permitted to copy and distribute verbatim copies
#  of this license document, but changing it is not allowed.
# 
# 			    Preamble
# 
#   The licenses for most software are designed to take away your
# freedom to share and change it.  By contrast, the GNU General Public
# License is intended to guarantee your freedom to share and change free
# software--to make sure the software is free for all its users.  This
# General Public License applies to most of the Free Software
# Foundation's software and to any other program whose authors commit to
# using it.  (Some other Free Software Foundation software is covered by
# the GNU Lesser General Public License instead.)  You can apply it to
# your programs, too.
# 
#   When we speak of free software, we are referring to freedom, not
# price.  Our General Public Licenses are designed to make sure that you
# have the freedom to distribute copies of free software (and charge for
# this service if you wish), that you receive source code or can get it
# if you want it, that you can change the software or use pieces of it
# in new free programs; and that you know you can do these things.
# 
#   To protect your rights, we need to make restrictions that forbid
# anyone to deny you these rights or to ask you to surrender the rights.
# These restrictions translate to certain responsibilities for you if you
# distribute copies of the software, or if you modify it.
# 
#   For example, if you distribute copies of such a program, whether
# gratis or for a fee, you must give the recipients all the rights that
# you have.  You must make sure that they, too, receive or can get the
# source code.  And you must show them these terms so they know their
# rights.
# 
#   We protect your rights with two steps: (1) copyright the software, and
# (2) offer you this license which gives you legal permission to copy,
# distribute and/or modify the software.
# 
#   Also, for each author's protection and ours, we want to make certain
# that everyone understands that there is no warranty for this free
# software.  If the software is modified by someone else and passed on, we
# want its recipients to know that what they have is not the original, so
# that any problems introduced by others will not reflect on the original
# authors' reputations.
# 
#   Finally, any free program is threatened constantly by software
# patents.  We wish to avoid the danger that redistributors of a free
# program will individually obtain patent licenses, in effect making the
# program proprietary.  To prevent this, we have made it clear that any
# patent must be licensed for everyone's free use or not licensed at all.
# 
#   The precise terms and conditions for copying, distribution and
# modification follow.
# 
# 		    GNU GENERAL PUBLIC LICENSE
#    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
# 
#   0. This License applies to any program or other work which contains
# a notice placed by the copyright holder saying it may be distributed
# under the terms of this General Public License.  The "Program", below,
# refers to any such program or work, and a "work based on the Program"
# means either the Program or any derivative work under copyright law:
# that is to say, a work containing the Program or a portion of it,
# either verbatim or with modifications and/or translated into another
# language.  (Hereinafter, translation is included without limitation in
# the term "modification".)  Each licensee is addressed as "you".
# 
# Activities other than copying, distribution and modification are not
# covered by this License; they are outside its scope.  The act of
# running the Program is not restricted, and the output from the Program
# is covered only if its contents constitute a work based on the
# Program (independent of having been made by running the Program).
# Whether that is true depends on what the Program does.
# 
#   1. You may copy and distribute verbatim copies of the Program's
# source code as you receive it, in any medium, provided that you
# conspicuously and appropriately publish on each copy an appropriate
# copyright notice and disclaimer of warranty; keep intact all the
# notices that refer to this License and to the absence of any warranty;
# and give any other recipients of the Program a copy of this License
# along with the Program.
# 
# You may charge a fee for the physical act of transferring a copy, and
# you may at your option offer warranty protection in exchange for a fee.
# 
#   2. You may modify your copy or copies of the Program or any portion
# of it, thus forming a work based on the Program, and copy and
# distribute such modifications or work under the terms of Section 1
# above, provided that you also meet all of these conditions:
# 
#     a) You must cause the modified files to carry prominent notices
#     stating that you changed the files and the date of any change.
# 
#     b) You must cause any work that you distribute or publish, that in
#     whole or in part contains or is derived from the Program or any
#     part thereof, to be licensed as a whole at no charge to all third
#     parties under the terms of this License.
# 
#     c) If the modified program normally reads commands interactively
#     when run, you must cause it, when started running for such
#     interactive use in the most ordinary way, to print or display an
#     announcement including an appropriate copyright notice and a
#     notice that there is no warranty (or else, saying that you provide
#     a warranty) and that users may redistribute the program under
#     these conditions, and telling the user how to view a copy of this
#     License.  (Exception: if the Program itself is interactive but
#     does not normally print such an announcement, your work based on
#     the Program is not required to print an announcement.)
# 
# These requirements apply to the modified work as a whole.  If
# identifiable sections of that work are not derived from the Program,
# and can be reasonably considered independent and separate works in
# themselves, then this License, and its terms, do not apply to those
# sections when you distribute them as separate works.  But when you
# distribute the same sections as part of a whole which is a work based
# on the Program, the distribution of the whole must be on the terms of
# this License, whose permissions for other licensees extend to the
# entire whole, and thus to each and every part regardless of who wrote it.
# 
# Thus, it is not the intent of this section to claim rights or contest
# your rights to work written entirely by you; rather, the intent is to
# exercise the right to control the distribution of derivative or
# collective works based on the Program.
# 
# In addition, mere aggregation of another work not based on the Program
# with the Program (or with a work based on the Program) on a volume of
# a storage or distribution medium does not bring the other work under
# the scope of this License.
# 
#   3. You may copy and distribute the Program (or a work based on it,
# under Section 2) in object code or executable form under the terms of
# Sections 1 and 2 above provided that you also do one of the following:
# 
#     a) Accompany it with the complete corresponding machine-readable
#     source code, which must be distributed under the terms of Sections
#     1 and 2 above on a medium customarily used for software interchange; or,
# 
#     b) Accompany it with a written offer, valid for at least three
#     years, to give any third party, for a charge no more than your
#     cost of physically performing source distribution, a complete
#     machine-readable copy of the corresponding source code, to be
#     distributed under the terms of Sections 1 and 2 above on a medium
#     customarily used for software interchange; or,
# 
#     c) Accompany it with the information you received as to the offer
#     to distribute corresponding source code.  (This alternative is
#     allowed only for noncommercial distribution and only if you
#     received the program in object code or executable form with such
#     an offer, in accord with Subsection b above.)
# 
# The source code for a work means the preferred form of the work for
# making modifications to it.  For an executable work, complete source
# code means all the source code for all modules it contains, plus any
# associated interface definition files, plus the scripts used to
# control compilation and installation of the executable.  However, as a
# special exception, the source code distributed need not include
# anything that is normally distributed (in either source or binary
# form) with the major components (compiler, kernel, and so on) of the
# operating system on which the executable runs, unless that component
# itself accompanies the executable.
# 
# If distribution of executable or object code is made by offering
# access to copy from a designated place, then offering equivalent
# access to copy the source code from the same place counts as
# distribution of the source code, even though third parties are not
# compelled to copy the source along with the object code.
# 
#   4. You may not copy, modify, sublicense, or distribute the Program
# except as expressly provided under this License.  Any attempt
# otherwise to copy, modify, sublicense or distribute the Program is
# void, and will automatically terminate your rights under this License.
# However, parties who have received copies, or rights, from you under
# this License will not have their licenses terminated so long as such
# parties remain in full compliance.
# 
#   5. You are not required to accept this License, since you have not
# signed it.  However, nothing else grants you permission to modify or
# distribute the Program or its derivative works.  These actions are
# prohibited by law if you do not accept this License.  Therefore, by
# modifying or distributing the Program (or any work based on the
# Program), you indicate your acceptance of this License to do so, and
# all its terms and conditions for copying, distributing or modifying
# the Program or works based on it.
# 
#   6. Each time you redistribute the Program (or any work based on the
# Program), the recipient automatically receives a license from the
# original licensor to copy, distribute or modify the Program subject to
# these terms and conditions.  You may not impose any further
# restrictions on the recipients' exercise of the rights granted herein.
# You are not responsible for enforcing compliance by third parties to
# this License.
# 
#   7. If, as a consequence of a court judgment or allegation of patent
# infringement or for any other reason (not limited to patent issues),
# conditions are imposed on you (whether by court order, agreement or
# otherwise) that contradict the conditions of this License, they do not
# excuse you from the conditions of this License.  If you cannot
# distribute so as to satisfy simultaneously your obligations under this
# License and any other pertinent obligations, then as a consequence you
# may not distribute the Program at all.  For example, if a patent
# license would not permit royalty-free redistribution of the Program by
# all those who receive copies directly or indirectly through you, then
# the only way you could satisfy both it and this License would be to
# refrain entirely from distribution of the Program.
# 
# If any portion of this section is held invalid or unenforceable under
# any particular circumstance, the balance of the section is intended to
# apply and the section as a whole is intended to apply in other
# circumstances.
# 
# It is not the purpose of this section to induce you to infringe any
# patents or other property right claims or to contest validity of any
# such claims; this section has the sole purpose of protecting the
# integrity of the free software distribution system, which is
# implemented by public license practices.  Many people have made
# generous contributions to the wide range of software distributed
# through that system in reliance on consistent application of that
# system; it is up to the author/donor to decide if he or she is willing
# to distribute software through any other system and a licensee cannot
# impose that choice.
# 
# This section is intended to make thoroughly clear what is believed to
# be a consequence of the rest of this License.
# 
#   8. If the distribution and/or use of the Program is restricted in
# certain countries either by patents or by copyrighted interfaces, the
# original copyright holder who places the Program under this License
# may add an explicit geographical distribution limitation excluding
# those countries, so that distribution is permitted only in or among
# countries not thus excluded.  In such case, this License incorporates
# the limitation as if written in the body of this License.
# 
#   9. The Free Software Foundation may publish revised and/or new versions
# of the General Public License from time to time.  Such new versions will
# be similar in spirit to the present version, but may differ in detail to
# address new problems or concerns.
# 
# Each version is given a distinguishing version number.  If the Program
# specifies a version number of this License which applies to it and "any
# later version", you have the option of following the terms and conditions
# either of that version or of any later version published by the Free
# Software Foundation.  If the Program does not specify a version number of
# this License, you may choose any version ever published by the Free Software
# Foundation.
# 
#   10. If you wish to incorporate parts of the Program into other free
# programs whose distribution conditions are different, write to the author
# to ask for permission.  For software which is copyrighted by the Free
# Software Foundation, write to the Free Software Foundation; we sometimes
# make exceptions for this.  Our decision will be guided by the two goals
# of preserving the free status of all derivatives of our free software and
# of promoting the sharing and reuse of software generally.
# 
# 			    NO WARRANTY
# 
#   11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
# FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
# OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
# PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
# OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
# TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
# PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
# REPAIR OR CORRECTION.
# 
#   12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
# WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
# REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
# INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
# TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
# YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
# PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGES.
# 
# 		     END OF TERMS AND CONDITIONS
require 'enumerator'

class Email < ActiveRecord::Base
  belongs_to :account
  validates_presence_of :account_id

  belongs_to :domain
  has_many :mass_recipients, :class_name => "MassRecipient", :dependent => :delete_all, :foreign_key => "email_id", :extend => Extensions::MassRecipients
  validate :ccs_and_bccs_is_empty

  after_save :build_tos
  after_save :build_ccs
  after_save :build_bccs

  ValidMailTypes = %w(HTML Plain HTML+Plain).freeze
  validates_inclusion_of :mail_type, :in => ValidMailTypes

  def domain_name
    self.domain.name
  end

  # The tags on Email itself relate to the +sender+, not any of the recipients.
  # The tags on Recipient relate to that recipient only.
  acts_as_taggable
  acts_as_fulltext %w(subject recipients_as_text dates_as_text tag_list)

  # We record the last exception's backtrace to help us trace the root cause of the problem.
  serialize :backtrace

  belongs_to :smtp_email_account

  has_many :attachments
  has_many :assets, :through => :attachments

  belongs_to :about, :polymorphic => true
  has_many :emails, :as => :about

  has_and_belongs_to_many :filters

  # A secondary recipient is created when the same email from a same pop3 account
  # is retrieved by another party
  has_many :secondaries, :class_name => "SecondaryRecipient", :dependent => :delete_all

  has_many :tos, :class_name => "ToRecipient", :dependent => :delete_all, :extend => Extensions::Recipients
  has_many :bccs, :class_name => "BccRecipient", :dependent => :delete_all, :extend => Extensions::Recipients
  has_many :ccs, :class_name => "CcRecipient", :dependent => :delete_all, :extend => Extensions::Recipients

  has_one :sender, :dependent => :delete
  validate :sender_cant_be_blank

  # Keep the parsed bodies and subjects around, so we
  # only have to do data interpolation at sending time.
  validate :verify_liquid_templates_syntax
  after_validation :dump_liquid_templates

  attr_accessor :current_user

  def mailbox
    return "inbox" if self.received_at
    return "outbox" if self.released_at && self.sent_at.nil?
    return "draft" if self.released_at.nil? && self.sent_at.nil? && self.received_at.nil?
    return "sent" if self.sent_at
    return nil
  end

  def to_s
    self.subject.to_s.inspect
  end

  #for email filters
  def apply_filters(user)
    return if user.blank?
    logger.debug("^^^Applying filter to email# #{self.id}")
    user.filters.each do |filter|
      all_lines_passed = true
      filter.filter_lines.each do |line|
        logger.debug("^^^Field: #{line.field}")
        case line.operator
        when "eq"
          regex = /^#{line.value}$/
        when "start"
          regex = /^#{line.value}/
        when "end"
          regex = /#{line.value}$/
        when "contain"
          regex = /#{line.value}/
        end
        case line.field
        when "from"
          match = line.exclude ? !(self.sender.address =~ regex) : self.sender.address =~ regex
          all_lines_passed = all_lines_passed && match
        when "to"
          tos_passed = false
          %w(tos bccs ccs).each do |recipient_type|
            self.send(recipient_type).each do |recipient|
              tos_passed = tos_passed || recipient.address =~ regex
              break if tos_passed
            end
            break if tos_passed
          end
          all_lines_passed = all_lines_passed && (line.exclude ? !tos_passed : tos_passed)
        when "subject"
          all_lines_passed = all_lines_passed && (line.exclude ? !(self.subject =~ regex) : self.subject =~ regex)
        when "body"
          all_lines_passed = all_lines_passed && (line.exclude ? !(self.body =~ regex) : self.body =~ regex)
        end
      end
      filter.emails << self if all_lines_passed
    end
  end

  def self.find_my_emails_with_users(user_ids, current_account, current_user)
    user_ids_arr = []
    user_ids.split(',').each{|id| user_ids_arr << id.to_i} unless user_ids.blank?

    return [] if user_ids_arr.empty?
    user_email_ids = Email.connection.select_values("SELECT DISTINCT email_id FROM recipients WHERE recipients.party_id = #{current_user.id}")
    record_email_ids = Email.connection.select_values("SELECT DISTINCT email_id FROM recipients WHERE recipients.party_id IN (#{user_ids_arr.join(',')})")

    email_ids = user_email_ids & record_email_ids

    return [] if email_ids.empty?

    Email.find(:all, :order => 'CONCAT_WS("", emails.sent_at, emails.received_at) DESC', :limit => 30,
      :conditions => ["emails.id IN (#{email_ids.join(',')}) AND (emails.sent_at IS NOT NULL OR emails.received_at IS NOT NULL)"])
  end

  def self.find_users_emails(user_ids, current_account)
    user_ids_arr = []
    user_ids.split(',').map(&:strip).each{|id| user_ids_arr << id.to_i} unless user_ids.blank?

    return [] if user_ids_arr.empty?
    email_ids = Email.connection.select_values("SELECT DISTINCT email_id FROM recipients WHERE recipients.party_id IN (#{user_ids_arr.join(',')})").reject(&:blank?)
    return [] if email_ids.empty?

    # We do not fear a SQL injection attack for email_ids, because we just got it from the database itself.
    Email.find(:all, :order => 'CONCAT_WS("", emails.sent_at, emails.received_at) DESC', :limit => 30,
      :conditions => "emails.id IN (#{email_ids.join(',')}) AND (emails.sent_at IS NOT NULL OR emails.received_at IS NOT NULL)")
  end

  def read_by(user, time=Time.now)
    [self.tos, self.ccs, self.bccs, self.secondaries].map {|coll| coll.find_by_party_id(user.id)}.compact.each do |party|
      party.update_attribute(:read_at, time)
    end
  end

  def to_xml(options={})
    options[:indent] ||= 2
    xml = options[:builder] ||= Builder::XmlMarkup.new(:indent => options[:indent])
    xml.instruct! unless options[:skip_instruct]
    xml.email(:id => self.dom_id) do
      xml.tag! "date", self.received_at.to_date
      xml.tag! "from", self.sender.address
      xml.tag! "subject", self.subject
      xml.tag! "hasCompleted", self.sender.read_at? ? "true" : "false"
      xml.tag! "body", self.body
    end
  end

  def total_number_of_recipients
    [self.tos(true), self.ccs(true),
        self.bccs(true)].flatten.map(&:email_addresses).flatten.size
  end

  def tos=(*recipients)
    @_tos = recipients.flatten
  end

  def ccs=(*recipients)
    return if self.mass_mail?
    @_ccs = recipients.flatten
  end

  def bccs=(*recipients)
    return if self.mass_mail?
    @_bccs = recipients.flatten
  end

  def sender_with_params=(params_or_sender)
    case params_or_sender
    when Sender
      logger.debug {"==> Sender"}
      self.sender_without_params = params_or_sender
    when Party
      logger.debug {"==> Party"}
      self.build_sender(:party => params_or_sender)
    when Hash
      logger.debug {"==> Hash"}
      self.build_sender(params_or_sender)
    else
      raise ArgumentError, "Expected an instance of Sender, Party or Hash"
    end

    logger.debug {"==> sender: #{self.sender.inspect}"}
    self.sender.account = self.account

    returning(self.sender) do |sender|

      if sender.address.blank? then
        sender.send(:assign_default_address_and_name) unless sender.party_id.blank?
        raise ArgumentError, "Mail is being sent from nobody ?  Couldn't find any address to send from" if sender.address.blank?
      else
        route = self.account.email_contact_routes.find_by_address_and_routable_type(sender.address, "Party")
        sender.party = route.routable if route
      end
    end
  end
  alias_method_chain :sender=, :params

  def from
    addr = read_attribute(:from_address)
    addr.blank? ? "#{self.sender.name.to_forward_s} <#{self.sender.email}>" : addr
  end

  def from=(address)
    write_attribute(:from_address, :address)
  end

  # TODO remove this method as well?
  def build_email
    email = self.class.new(self.attributes)
    email.account = self.account
    email.released_at = email.scheduled_at = email.sent_at = nil
    email
  end

  def release(now=Time.now)
    self.released_at = now
    self.save
  end

  def release!(now=Time.now)
    self.released_at = now
    self.save!
  end

  def unrelease!
    self.released_at = nil
    self.save!
  end

  # TODO this method should send normal email, not sending out invidual email (mass email)
  # <b>WARNING: long operation</b>.
  # Sends this E-Mail to each recipient.
  # This is a NOP if the email is not ready or it is scheduled and its time
  # has not come to pass.
  def send!(now=Time.now)
    return unless self.ready?
    return if self.scheduled_at and self.scheduled_at > now
    return if self.sent?

    begin
      if self.mass_mail? then
        self.send_mass_mail!(now)
      else
        self.send_regular_mail!(now)
      end
    rescue Object, Exception
      self.reload

      # Try to send the mail again 30 minutes from now
      self.scheduled_at = 30.minutes.from_now
      self.error = $!.message
      self.backtrace = $!.backtrace.join("\n")
      self.error_count += 1
      self.save!

      raise "Could not send E-Mail #{self.id}: #{$!.message}" if self.error_count > 4
    end
  end

  def record_error(exception)
    self.error = exception.message
    self.error_count += 1
    self.backtrace = exception.backtrace
  end

  # Reschedule sending this mail at some later date
  def reschedule!(at=1.hour.from_now)
    self.scheduled_at = at
    self.save(false)
  end

  def error_limit_reached?
    self.error_count >= 1
  end

  def mark_bad_recipient!(recipient, reason)
    self.increment_bad_recipient_count
    self.released_at = nil
    self.save!
  end

  def return_non_delivery_to_sender!(reason)
    logger.debug {"==> return_non_delivery_to_sender!(#{self.id})"}
    self.class.transaction do
      self.released_at = nil
      self.save(false)

      non_delivery = self.account.emails.build(:subject => 'Undeliverable mail returned to sender',
          :about => self, :current_user => self.sender.party,
          :body => "The referenced E-Mail could not be sent for the following reason:\n  #{reason}\n\nSubject: #{self.subject}\n\nYou will need to release this E-Mail again after you correct the situation.  To release the mail, follow this link:\n  http://#{self.account.domain_name}/admin/emails/#{self.id}")
      non_delivery.tos.build(:party => self.sender.party, :extras => {}, :account =>  self.account,
          :name => self.sender.name, :address => self.sender.address)
      non_delivery.build_sender(:party => self.sender.party, :account => self.account,
        :address => self.sender.address, :name => self.sender.name)
      non_delivery.priority = 150
      non_delivery.save!
      non_delivery.release!
      non_delivery
    end
  end

  class << self
    def pluck_next_ready_mails
      with_scope(:find => {:conditions => "sent_at IS NULL AND released_at IS NOT NULL",
          :order => "scheduled_at, released_at"}) do
        self.find(:all, :conditions => ["scheduled_at IS NULL OR scheduled_at <= ?", Time.now.utc])
      end
    end

    def find_outbox
      self.find(:all, :conditions => 'released_at IS NOT NULL AND sent_at IS NULL AND received_at IS NULL',
                :order => 'released_at DESC')
    end

    def find_drafts
      self.find(:all, :order => "created_at DESC",
                :conditions => "released_at IS NULL AND sent_at IS NULL AND received_at IS NULL AND bad_recipient_count = 0")
    end
  end

  def main_identifier
    "#{self.subject} : #{self.status}"
  end

  def party_display_name
    self.sender ? self.sender.display_name : nil
  end

  def formatted_subject
    self.subject.blank? ? "(no subject)" : self.subject
  end

  def formatted_sender_name
    if self.sender && self.sender.party then
      return self.sender.party.name unless self.sender.party.name.blank?
    end

    "(unknown sender)"
  end

  def scheduled?
    self.scheduled_at
  end

  def received?
    self.status == :received
  end

  def sent?
    self.status == :sent
  end

  def ready?
    self.status == :ready
  end
  alias_method :released?, :ready?

  def draft?
    self.status == :draft
  end

  def unreleased?
    self.status == :unreleased
  end

  def status
    return :received if self.received_at
    return :sent if self.sent_at
    return :ready if (self.scheduled_at and self.scheduled_at <= Time.now and self.released_at) or (!self.scheduled_at and self.released_at)
    return :unreleased if self.scheduled_at and !self.released_at
    return :scheduled if self.scheduled_at
    :draft
  end

  def create_attachment!(params)
    return if params[:uploaded_data].size.zero?

    returning(self.attachments.create!(params)) do |attachment|
      (self.tos + self.ccs + self.bccs).each do |recipient|
        attachment.authorizations.create!(:name => recipient.party.name.to_s, :email => recipient.address)
      end

      attachment.authorizations.update_all("url_hash = '#{attachment.authorizations.first.url_hash}'")
    end
  end

  def clear_recipients_and_attachments
    %w(tos ccs bccs).each do |source|
      self.send(source).destroy_all
    end
    self.sender.destroy if self.sender
    self.attachments.destroy_all if self.attachments
    self.reload
  end

  def reply(current_user)
    prepare_reply(current_user) do |reply_email|
      # create recipient of the reply email: which is the sender of the initial email
      reply_email.tos.build(:address => self.sender.address, :name => self.sender.name,
          :account => reply_email.account, :party => self.sender.party)
      return reply_email
    end
  end

  def reply_to_all(current_user)
    prepare_reply(current_user) do |reply|
      reply.tos.build(:party => self.sender.party, :account => self.account, :email => reply,
          :address => self.sender.address, :name => self.sender.address)
      (self.tos + self.ccs).each do |recipient|
        #printf("%s: %s (%s)\n", recipient.address, recipient.name, (recipient.address == current_user.main_email.address).inspect)
        next if recipient.address == current_user.main_email.address
        reply.ccs.build(:name => recipient.name, :address => recipient.address, :email => reply,
            :account => self.account, :party => recipient.party)
      end
    end
  end

  def forward(current_user)
    prepare_forward(current_user) do |other|
    end
  end

  # Probably a better way to do this?
  def reply_forward_message_body
    message = []
    self.body.gsub("\r\n", "\n").each_line {|m| message << "> #{m.chomp}"}
    message.join("\n")
  end

  def self.find_bounced
    find(:all, :conditions => "about_id IS NOT NULL", :order => "sent_at DESC")
  end

  def belongs_to_party(party)
    temp = false
    %w(tos ccs bccs secondaries).each do |source|
      temp = temp || self.send(source).map(&:party_id).include?(party.id) unless self.send(source).blank?
      break if temp
    end
    return temp
  end

  def subject_template
    self.load_subject_template
  end

  def body_template
    self.load_body_template
  end

  protected
  def build_recipients(target, recipients)
    logger.debug {"==> \#build_recipients(#{target.inspect}, #{recipients.inspect})"}
    return if recipients.blank?
    recipients.flatten!
    recipients.collect! do |rcpt|
      next rcpt unless rcpt.respond_to?(:to_str)
      rcpt.split(/,|\n/)
    end
    recipients.flatten!
    
    parties, others = recipients.partition {|r| r.kind_of?(Party)}
    routes, others = others.partition {|r| r.kind_of?(EmailContactRoute)}

    routes.each do |route|
      self.send(target).create!(:account => self.account, :address => route.address, :recipient_builder_type => PartyListBuilder.name,
                                :recipient_builder_id => route.routable_id, :name => route.routable.name.to_s, :party => route.routable)
    end

    parties.each do |party|
      self.send(target).create!(:account => self.account, :address => party.main_email.address,
                                :recipient_builder_type => PartyListBuilder.name, :recipient_builder_id => party.id,
                                :name => party.name.to_s, :party => party)
    end

    others.map(&:strip).uniq.each do |email_plus_name|
      if email_plus_name =~ /\A\S+@\S+\.\S+\Z/i
        name, address = EmailContactRoute.decode_name_and_address(email_plus_name)
        unless address.blank?
          party = find_or_create_party_by_email_address(address)
          self.send(target).create!(:account => self.account, :address => address,
            :recipient_builder_type => PartyListBuilder.name, :recipient_builder_id => party.id,
            :name => name, :party => party)
        end
      elsif email_plus_name =~ /\Atag=(.+)\Z/i
        self.send(target).create!(:account => self.account, :tag_syntax => $1.strip,
            :recipient_builder_type => TagListBuilder.name)
      elsif email_plus_name =~ /\Asearch=(.+)\Z/i
        search = self.current_user.searches.find_by_name($1.strip)
        unless search.blank?
          self.send(target).create!(:account => self.account,
            :recipient_builder_id => search.id, :recipient_builder_type => SearchListBuilder.name)
        end
      elsif email_plus_name =~ /\Aaccount_owners(=(.+))?\Z/i
        self.send(target).create!(:account => self.account, :tag_syntax => $2.strip,
          :recipient_builder_id => nil, :recipient_builder_type => AccountOwnerListBuilder.name)
      else
        group = self.account.groups.find_by_name(email_plus_name)
        next if group.blank?
        self.send(target).create!(:account => self.account,
          :recipient_builder_id => group.id, :recipient_builder_type => GroupListBuilder.name)
      end
    end unless others.join().blank?
  end

  # helper method to takes care the creation of reply email object and its sender
  def prepare(current_user)
    raise "No recipients for E-Mail #{self.id}" if self.tos.empty? && self.bccs.empty? && self.ccs.empty?
    returning(current_user.account.emails.build(:current_user => current_user)) do |reply|
      reply.sender = current_user
      yield reply
    end
  end

  # helper method to generate subject and body of reply email
  # prepare_reply calls prepare method that creates the reply email object
  def prepare_reply(current_user, &block)
    prepare(current_user) do |reply_email|
      reply_email.subject = "Re: #{self.subject}"
      reply_email.body = <<EOF


On #{(self.received_at || Time.now).strftime('%Y-%m-%d %H:%M')}, #{self.sender.name} said:
#{reply_forward_message_body}
EOF
      yield(reply_email)
    end
  end

  def prepare_forward(current_user, &block)
    prepare(current_user) do |other|
      other.subject = "Fwd: #{self.subject}"
      other.body = <<EOF
Begin Forwarded Message:
> From: #{self.sender.to_formatted_s}
> Date: #{(self.received_at || Time.now).strftime('%Y-%m-%d %H:%M')}
> To: #{self.tos.to_formatted_s}
> Cc: #{self.ccs.to_formatted_s}
> Subject: #{self.subject}
>
#{reply_forward_message_body}
EOF

      yield(other)
    end
  end

  def sender_cant_be_blank
    self.errors.add_to_base("Please specify sender of the email") if self.sender.blank?
  end

  def find_or_create_party_by_email_address(email_address)
    email_contact_route = self.account.email_contact_routes.find_by_address_and_routable_type(email_address, "Party")
    return email_contact_route.routable if email_contact_route

    Party.transaction do
      returning self.account.parties.create! do |party|
        EmailContactRoute.create!(:address => email_address, :routable => party, :account => self.account)
      end
    end
  end

  # Sender is a type of recipient, so it is included here
  def recipients_as_text
    [self.sender, self.tos, self.ccs, self.bccs].flatten.map do |rcpt|
      [rcpt.name, rcpt.address]
    end
  end

  def dates_as_text
    returning [] do |dates|
      dates += [self.received_at.to_s(:iso), self.received_at.to_s(:short)] if self.received_at
      dates += [self.sent_at.to_s(:iso), self.sent_at.to_s(:short)] if self.sent_at
    end
  end

  def generate_mass_recipients
    self.class.transaction do
      logger.debug {"==> Removing existing mass recipients"}
      self.mass_recipients.delete_all
      logger.debug {"==> Processing #{self.tos.count} recipients"}
      self.tos.each do |recipient|
        recipient.email_addresses.each do |route|
          party = route.routable
          next unless party.kind_of?(Party)

          next if self.mass_recipients(true).map(&:address).index(route.address)

          attrs = {}
          attrs['from'] = recipient.email.sender.to_formatted_s
          attrs['now'] = Time.now
          attrs['year'] = attrs['now'].year
          attrs['month'] = attrs['now'].month
          attrs['month_name'] = FULL_MONTH_NAMES[attrs['month'] - 1]

          attrs['full_name'] = party.display_name
          attrs['company_name'] = party.company_name
          attrs['name'] = party.name.to_s
          attrs['name_only'] = party.name.to_s
          attrs['first_name'] = party.name.first
          attrs['last_name'] = party.name.last
          attrs['middle_name'] = party.name.middle
          attrs['email'] = party.main_email.address
          attrs['login_info'] = party.main_email.address
          attrs['uuid'] = party.uuid

          if address = party.main_address then
            attrs['line1'] = address.line1
            attrs['line2'] = address.line2
            attrs['city'] = address.city
            attrs['state'] = address.state
            attrs['zip'] = address.zip
            attrs['country'] = address.country
          end
          
          if self.body =~ /\{\{\s*randomize_password_if_none\s*\}\}/ && recipient.party.password_hash.blank? then
            party = recipient.party
            pw = party.randomize_password!
            unless pw.blank?
              party.confirmation_token = nil
              party.confirmation_token_expires_at = nil
              party.confirmed = true
              party.save!
              attrs['randomize_password_if_none'] = "Password: #{pw}"
            end
          end
          
          # TODO do something about reset password email
          if recipient.email.generate_password then
            attrs['new_password'] = recipient.party.randomize_password!
          end

          self.mass_recipients.create!(:name => route.fullname, :address => route.address, :account => self.account,
              :party_id => route.routable_id, :extras => attrs)
        end
      end

      logger.debug {"==> Done generating mass recipients"}
    end
  end

  def make_recipient(recipient)
    logger.debug {"==> Building for #{recipient.inspect}"}
    send_to = self.tos.build(:account => self.account, :email => self)

    case recipient
    when Party
      send_to.update_attributes(:party => recipient)

    when /\Atag\s*[=:]\s*(.+)\Z/i
      send_to.update_attributes(:tag_syntax => $1.strip,
                                :recipient_builder_type => TagListBuilder.name)

    when /\Asearch[=:](.+)\Z/i
      search = self.current_user.searches.find_by_name($1)
      raise ActiveRecord::RecordNotFound, "Could not find search named #{$1.inspect}" if search.blank?
      send_to.update_attributes(:recipient_builder_id => search.id,
                                :recipient_builder_type => SearchListBuilder.name)

    when /\Aaccount_owners(=(.+))?\Z/i
      send_to.update_attributes(:tag_syntax => $1,
                                :recipient_builder_type => AccountOwnerListBuilder.name)

    when /\A(\w|\s)*\S+@\S+\.\S+\Z/i
      valid_email = recipient.match(EmailContactRoute::ValidAddressRegexp)
      if valid_email
        recipient = valid_email[0]
      else
        return
      end
      party = find_or_create_party_by_email_address(recipient)
      send_to.update_attributes(:address => recipient,
                                :recipient_builder_type => PartyListBuilder.name, :party => party)

    else
      group = self.account.groups.find_by_name(recipient)
      raise ActiveRecord::RecordNotFound, "Could not find group named #{recipient.inspect}" if group.blank?
      send_to.update_attributes(:recipient_builder_id => group.id,
                                :recipient_builder_type => GroupListBuilder.name)
    end
  end

  def ccs_and_bccs_is_empty
    return unless self.mass_mail?
    self.errors.add(:ccs, "must be blank") unless (@_ccs.blank? && self.ccs.blank?)
    self.errors.add(:bccs, "must be blank") unless (@_bccs.blank? && self.bccs.blank?)
  end

  # sends email to each MassRecipient
  def send_mass_mail!(now=Time.now)
    logger.debug {"==> Generating mass recipients for #{self.id}"}
    self.generate_mass_recipients if self.mass_recipients.empty?
    logger.debug {"==> There are #{self.mass_recipients.unsent_count} unsent recipients out of #{self.mass_recipients.count}"}
    self.class.transaction do
      self.mass_recipients.unsent.in_groups_of(100, false) do |group|
        priority = group.compact.size <= 10 ? 100 : 250
        MethodCallbackFuture.create!(:models => group, :method => :send!, :system => true, :account => self.account, :priority => priority)
      end

      self.tag_list = self.tag_list << ' sent'
      self.sent_at = Time.now.utc
      self.save!
    end
  end

  def send_regular_mail!(now)
    begin
      recipients = [self.tos, self.ccs, self.bccs]
      raise NoRecipientsError if recipients.map(&:count).sum.zero?
      MassMailer.deliver_mailing(self)
      self.update_attribute(:sent_at, now)
    rescue NoRecipientsError
      logger.warn {$!}
      self.record_error($!)
      self.return_non_delivery_to_sender!("No recipients")

    rescue Net::SMTPError
      self.record_error($!) # No save, as the next two calls save the record

      if self.error_limit_reached? then
        self.return_non_delivery_to_sender!("Exceeded retry count (#{self.error_count} times)")
      else
        self.reschedule!(1.hour.from_now)
      end
    end
  end

  def build_tos
    recipients = @_tos
    @_tos = nil
    return unless recipients
    if self.mass_mail? then
      logger.debug {"==> mass email"}
      self.tos.clear
      return if recipients.blank? || recipients.all?(&:blank?)
      recipients.collect! do |rcpt|
        next rcpt unless rcpt.respond_to?(:to_str)
        rcpt.to_str.split(/,|\n/).map(&:strip).uniq
      end

      logger.debug {"==> recipients: #{recipients.inspect}"}
      recipients.flatten.each do |rcpt|
        make_recipient(rcpt)
      end
    else
      logger.debug {"==> regular mail"}
      build_recipients(:tos, recipients)
    end
  end
  
  def build_ccs
    build_recipients(:ccs, @_ccs)
    @_ccs = nil
  end
  
  def build_bccs
    build_recipients(:bccs, @_bccs)
    @_bccs = nil
  end

  def verify_liquid_templates_syntax
    begin
      @liquid_subject_template = Liquid::Template.parse(self.subject)
    rescue SyntaxError
      self.errors.add(:subject, "is invalid: #{$!.message}")
    end

    begin
      @liquid_body_template = Liquid::Template.parse(self.body)
    rescue SyntaxError
      self.errors.add(:body, "is invalid: #{$!.message}")
    end
  end

  def dump_liquid_templates
    self.parsed_subject = Marshal.dump(@liquid_subject_template)
    self.parsed_body = Marshal.dump(@liquid_body_template)
  end

  def load_subject_template
    @liquid_subject_template ||= Marshal.load(self.parsed_subject)
  end

  def load_body_template
    @liquid_body_template ||= Marshal.load(self.parsed_body)
  end

  def increment_bad_recipient_count
    self.class.connection.execute("UPDATE emails SET bad_recipient_count = bad_recipient_count + 1 WHERE id=#{self.id}")
  end  
end
